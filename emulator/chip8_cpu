/*////////////////////////////////////////////////////////////////////////////////////////////////////////////

        Chip-8 is an interpreted programming language and is mostly famous among computer enthusiasts
        as a means of powering their DIY PCs. As a part of CMPT 276 group project by 6 SFU students, this
        Chip-8 emulator was created using JavaScript, HTML and CSS under the guidance of Dr. Toby
        Donaldson.

        This emulator consists of a CPU object, opcode implementations and the screen module.

////////////////////////////////////////////////////////////////////////////////////////////////////////////*/                                                                                        

let CHIP8 = {
    V: new Uint8Array(16),          // V0 to Vf are 16 8-bit registers
    register_I: 0,                  // Special 16-bit address register I
    
    memory: new Uint8Array(4096),   // 4K (4096) bytes of memory
    pc: 0x200,                      // Program counter (16-bit) starts at 0x200 (512)

    stack: new Uint16Array(16),     // Array of 16 16-bit values
    stackPointer: -1,               // Points to the top of the stack

    delayTimer: 0,                  // Delay timer initialized to 0
    soundTimer: 0,                  // Sound timer initialized to 0

    reg_reset() {
        this.V = new Uint8Array(16);
    },

    mem_reset() {
        for (let i = 0; i < 4096; i++) {
            this.memory.fill(0);
        }
    },

    reset() {
        this.reg_reset();
        this.mem_reset();
        this.register_I = 0;
        this.pc = 0x200;
        this.stack = new Uint16Array(16);
        this.stackPointer = -1;
        this.delayTimer = 0;
        this.soundTimer = 0;
    },

    loadProgram(program) {
        for (let i = 0; i < program.length; i++) {
            this.memory[this.pc + i] = program[i];
        }
    }
}

function emulateOpcode (opcode) {
	let code = opcode;		                // 1111-2222-3333-4444
    let x = (code & 0x0F00) >>> 8;          // 0x00
    let y = (code & 0x00F0) >>> 4;          // 00y0
    let kk = code & 0x00FF;                 // 00kk

	switch (code & 0xF000) {
		case 0x0000:
			
			switch (code & 0x00FF) {

				case 0x00E0:

					// 00E0 - CLS
					break;

				case 0x00EE:

					// 00EE - RET
					CHIP8.pc = CHIP8.stack[CHIP8.stackPointer];
					CHIP8.stack.pop();
					CHIP8.stackPointer--;
					break;
			}

			break;

		case 0x1000:

			// 1nnn - JP addr
			CHIP8.pc = (code & 0x0FFF)
			break;

		case 0x2000:

			// 2nnn - CALL addr
			CHIP8.stack.push(CHIP8.pc + 2);
			CHIP8.stackPointer++;
			CHIP8.pc = (code & 0x0FFF);
			break;

		case 0x3000:

			// 3xkk - SE Vx, byte
			if (CHIP8.V[x] === (code & 0x00FF))
				CHIP8.pc += 2;
			CHIP8.pc += 2;
			break;

		case 0x4000:

			// 4xkk - SNE Vx, byte
			if (CHIP8.V[x] !== (code & 0x00FF))
				CHIP8.pc += 2;
			CHIP8.pc += 2;
			break;

		case 0x5000:

			// 5xy0 - SE Vx, Vy
			if (CHIP8.V[x] === CHIP8.V[y])
				CHIP8.pc += 2;
			CHIP8.pc += 2;
			break;

		case 0x6000:

			// 6xkk - LD Vx, byte
			CHIP8.V[x] = kk;
			CHIP8.pc += 2;
			break;

		case 0x7000:

			// 7xkk - ADD Vx, byte
			CHIP8.V[x] += kk;
			CHIP8.pc += 2;
			break;

		case 0x8000:

			switch (code & 0x000F) {

				case 0x0000:

					// 8xy0 - LD Vx, Vy
					CHIP8.V[x] = CHIP8.V[y];
					CHIP8.pc += 2;
					break;

				case 0x0001:

					// 8xy1 - OR Vx, Vy
					CHIP8.V[x] = CHIP8.V[x] | CHIP8.V[y];
					CHIP8.pc += 2;
					break;

				case 0x0002:

					// 8xy2 - AND Vx, Vy
					CHIP8.V[x] = CHIP8.V[x] & CHIP8.V[y];
					CHIP8.pc += 2;
					break;

				case 0x0003:

					// 8xy3 - XOR Vx, Vy
					CHIP8.V[x] = CHIP8.V[x] ^ CHIP8.V[y];
					CHIP8.pc += 2;
					break;

				case 0x0004:

					// 8xy4 - ADD Vx, Vy
                    let sum = CHIP8.V[x] + CHIP8.V[y];
                    if (sum > 0xff)
                        CHIP8.V[15] = 1;
                    else
                        CHIP8.V[15] = 0;
                    CHIP8.V[x] = sum;
					break;

				case 0x0005:

					// 8xy5 - SUB Vx, Vy
					if (CHIP8.V[x] > CHIP8.V[y])
                        CHIP8.V[15] = 1;           // Vf = Not Borrow
                    else
                        CHIP8.V[15] = 0;
                    CHIP8.V[x] -= CHIP8.V[y];
					CHIP8.pc += 2;
					break;

				case 0x0006:

                    // 8xy6 - SHR Vx {, Vy}
                    if (CHIP8.V[x] & 0x01)
                        CHIP8.V[15] = 1;
                    else
                        CHIP8.V[15] = 0;
                    CHIP8.V[x] = CHIP8.V[x] >>> 1;    // >> or >>>
                    break;

				case 0x0007:

					// 8xy7 - SUBN Vx, Vy
					if (CHIP8.V[y] > CHIP8.V[x])	    // Vf = Not Borrow
                        CHIP8.V[15] = 1;
                    else
                        CHIP8.V[15] = 0;
                    CHIP8.V[x] = CHIP8.V[y] - CHIP8.V[x];
					CHIP8.pc += 2;
					break;

				case 0x000E:

                    // 8xyE - SHL Vx {, Vy}
                    if (CHIP8.V[x] & 0x80)
                        CHIP8.V[15] = 1;
                    else
                        CHIP8.V[15] = 0;
                    CHIP8.V[x] = CHIP8.V[x] << 1;
                    break;

			}

		case 0x9000:

			// 9xy0 - SNE Vx, Vy
			if (CHIP8.V[x] !== CHIP8.V[y])
				CHIP8.pc += 2;
			CHIP8.pc += 2;
			break;

		case 0xA000:

			// Annn - LD I, addr
			CHIP8.register_I = code & 0x0FFF;
			CHIP8.pc += 2;
			break;

		case 0xB000:

			// Bnnn - JP V0, addr
			CHIP8.pc = CHIP8.V[0] + (code & 0x0FFF);
			break;

		case 0xC000:

			// Cxkk - RND Vx, byte
			let random_byte = Math.floor(Math.random() * 256);		// 0 to 255
			CHIP8.V[x] = random_byte & kk;
			CHIP8.pc += 2;
			break;

		case 0xD000:

			// Dxyn - DRW Vx, Vy, nibble
			break;

		case 0xE000:

			switch (code & 0x00FF) {

				case 0x009E:

					// Ex9E - SKP Vx
					if (CHIP8.keyPressed === CHIP8.V[x])
						CHIP8.pc += 2;
					CHIP8.pc += 2;
					break;

				case 0x00A1:

					// ExA1 - SKNP Vx
					if (CHIP8.keyPressed !== CHIP8.V[x])
						CHIP8.pc += 2;
					CHIP8.pc += 2;
					break;
			}

		case 0xF000:

			switch (code & 0x00FF) {

				case 0x0007:

					// Fx07 - LD Vx, DT
					CHIP8.V[x] = CHIP8.delay;
					CHIP8.pc += 2;
					break;

				case 0x000A:

					// Fx0A - LD Vx, K
					CHIP8.V[x] = CHIP8.keyPressed;
					CHIP8.pc += 2;
					break;

				case 0x0015:

					// Fx15 - LD DT, Vx
                    CHIP8.delay = CHIP8.V[x];
                    CHIP8.pc += 2;
					break;

				case 0x0018:

					// Fx18 - LD ST, Vx
                    CHIP8.sound = CHIP8.V[x];
                    CHIP8.pc += 2;
					break;

				case 0x001E:

                    // Fx1E - ADD I, Vx
                    CHIP8.register_I += CHIP8.V[x];
                    CHIP8.pc += 2;
					break;

				case 0x0029:

                    // Fx29 - LD F, Vx
                    CHIP8.register_I = CHIP8.V[x] * 5;
                    CHIP8.pc += 2;
					break;

				case 0x0033:

					// Fx33 - LD B, Vx
					break;

				case 0x0055:

                    // Fx55 - LD [I], Vx
                    for (let i = 0; i <= x; i++) {
                        CHIP8.memory[CHIP8.register_I + i] = CHIP8.V[i];
                    }
                    CHIP8.pc += 2;
					break;

				case 0x0065:

                    // Fx65 - LD Vx, [I]
                    for (let i = 0; i <= x; i++) {
                        CHIP8.V[i] = CHIP8.memory[CHIP8.register_I + i];
                    }
                    CHIP8.pc += 2;
					break;

			}

            break;
            // no default case (is it needed?)
    }
}
