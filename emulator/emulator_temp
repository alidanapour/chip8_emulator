// included math library
"use strict"

class CHIP_8 {};

function CPU() {
    this.V = new Uint8Array(16);            // V0 to Vf
    this.register_I = 0;                    // Special 16-bit address register I
    this.memory = new Uint8Array(4096);     // 4096 bytes
    this.pc = 0x200;                        // Program counter (16-bit) (programs start at 0x200)

    this.stack = new Array(16);             // Array of 16 16-bit Values
    this.stackPointer = -1;                 // Points to last element i.e. top of the stack
    
    this.keyPressed = null;	                // Key pressed
    this.delay = 0;				            // Delay timer
    this.sound = 0;				            // Sound timer
}

function CPU_init () {
	let c8 = new CPU;

	c8.pc = 0x200;
	c8.stackPointer = -1;
	c8.delay = 0;
	c8.sound = 0;
}


function emulateOpcode (c8 :any, opcode :number) {
	let code :number = opcode;		                // 1111-2222-3333-4444
    let x :number = (code >>> 8) & 0x0f;            // 0x00
    let y :number = (code >>> 4) & 0x00f;           // 00y0
    let kk :number = code & 0x00ff;                 // 00kk

	switch (code & 0xf000) {
		case 0x0000:
			
			switch (code & 0x00ff) {

				case 0x00e0:

					// 00E0 - CLS
					break;

				case 0x00ee:

					// 00EE - RET
					c8.pc = c8.stack[c8.stackPointer];
					c8.stack.pop();
					c8.stackPointer--;
					break;
				}

				break;

		case 0x1000:

			// 1nnn - JP addr
			c8.pc = (code & 0x0fff)
			break;

		case 0x2000:

			// 2nnn - CALL addr
			c8.stack.push(c8.pc + 2);
			c8.stackPointer++;
			c8.pc = (code & 0x0fff);
			break;

		case 0x3000:

			// 3xkk - SE Vx, byte
			if (c8.V[x] === (code & 0x00ff))
				c8.pc += 2;
			c8.pc += 2;
			break;

		case 0x4000:

			// 4xkk - SNE Vx, byte
			if (c8.V[x] !== (code & 0x00ff))
				c8.pc += 2;
			c8.pc += 2;
			break;

		case 0x5000:

			// 5xy0 - SE Vx, Vy
			if (c8.V[x] === c8.V[y])
				c8.pc += 2;
			c8.pc += 2;
			break;

		case 0x6000:

			// 6xkk - LD Vx, byte
			c8.V[x] = kk;
			c8.pc += 2;
			break;

		case 0x7000:

			// 7xkk - ADD Vx, byte
			c8.V[x] += kk;
			c8.pc += 2;
			break;

		case 0x8000:

			switch (code & 0x000f) {

				case 0x0000:

					// 8xy0 - LD Vx, Vy
					c8.V[x] = c8.V[y];
					c8.pc += 2;
					break;

				case 0x0001:

					// 8xy1 - OR Vx, Vy
					c8.V[x] = c8.V[x] | c8.V[y];
					c8.pc += 2;
					break;

				case 0x0002:

					// 8xy2 - AND Vx, Vy
					c8.V[x] = c8.V[x] & c8.V[y];
					c8.pc += 2;
					break;

				case 0x0003:

					// 8xy3 - XOR Vx, Vy
					c8.V[x] = c8.V[x] ^ c8.V[y];
					c8.pc += 2;
					break;

				case 0x0004:

					// 8xy4 - ADD Vx, Vy
                    let sum = c8.V[x] + c8.V[y];
                    if (sum > 0xff)
                        c8.V[15] = 1;
                    else
                        c8.V[15] = 0;
                    c8.V[x] = sum;
					break;

				case 0x0005:

					// 8xy5 - SUB Vx, Vy
					if (c8.V[x] > c8.V[y])
                        c8.V[15] = 1;           // Vf = Not Borrow
                    else
                        c8.V[15] = 0;
                    c8.V[x] -= c8.V[y];
					c8.pc += 2;
					break;

				case 0x0006:

                    // 8xy6 - SHR Vx {, Vy}
                    if (c8.V[x] & 0x01)
                        c8.V[15] = 1;
                    else
                        c8.V[15] = 0;
                    c8.V[x] = c8.V[x] >>> 1;    // >> or >>>
                    break;

				case 0x0007:

					// 8xy7 - SUBN Vx, Vy
					if (c8.V[y] > c8.V[x])	    // Vf = Not Borrow
                        c8.V[15] = 1;
                    else
                        c8.V[15] = 0;
                    c8.V[x] = c8.V[y] - c8.V[x];
					c8.pc += 2;
					break;

				case 0x000e:

                    // 8xyE - SHL Vx {, Vy}
                    if (c8.V[x] & 0x80)
                        c8.V[15] = 1;
                    else
                        c8.V[15] = 0;
                    c8.V[x] = c8.V[x] << 1;
                    break;

			}

		case 0x9000:

			// 9xy0 - SNE Vx, Vy
			if (c8.V[x] !== c8.V[y])
				c8.pc += 2;
			c8.pc += 2;
			break;

		case 0xa000:

			// Annn - LD I, addr
			c8.register_I = code & 0x0fff;
			c8.pc += 2;
			break;

		case 0xb000:

			// Bnnn - JP V0, addr
			c8.pc = c8.V[0] + (code & 0x0fff);
			break;

		case 0xc000:

			// Cxkk - RND Vx, byte
			let random_byte :number = Math.floor(Math.random() * 256);		// 0 to 255
			c8.V[x] = random_byte & kk;
			c8.pc += 2;
			break;

		case 0xd000:

			// Dxyn - DRW Vx, Vy, nibble
			break;

		case 0xe000:

			switch (code & 0x00ff) {

				case 0x009e:

					// Ex9E - SKP Vx
					if (c8.keyPressed === c8.V[x])
						c8.pc += 2;
					c8.pc += 2;
					break;

				case 0x00a1:

					// ExA1 - SKNP Vx
					if (c8.keyPressed !== c8.V[x])
						c8.pc += 2;
					c8.pc += 2;
					break;

			break;
			}

		case 0xf000:

			switch (code & 0x00ff) {

				case 0x0007:

					// Fx07 - LD Vx, DT
					c8.V[x] = c8.delay;
					c8.pc += 2;
					break;

				case 0x000a:

					// Fx0A - LD Vx, K
					c8.V[x] = c8.keyPressed;
					c8.pc += 2;
					break;

				case 0x0015:

					// Fx15 - LD DT, Vx
                    c8.delay = c8.V[x];
                    c8.pc += 2;
					break;

				case 0x0018:

					// Fx18 - LD ST, Vx
                    c8.sound = c8.V[x];
                    c8.pc += 2;
					break;

				case 0x001e:

                    // Fx1E - ADD I, Vx
                    c8.register_I += c8.V[x];
                    c8.pc += 2;
					break;

				case 0x0029:

                    // Fx29 - LD F, Vx
                    c8.register_I = c8.V[x] * 5;
                    c8.pc += 2;
					break;

				case 0x0033:

					// Fx33 - LD B, Vx
					break;

				case 0x0055:

                    // Fx55 - LD [I], Vx
                    for (let i :number = 0; i <= x; i++) {
                        c8.memory[c8.register_I + i] = c8.V[i];
                    }
                    c8.pc += 2;
					break;

				case 0x0065:

                    // Fx65 - LD Vx, [I]
                    for (let i :number = 0; i <= x; i++) {
                        c8.V[i] = c8.memory[c8.register_I + i];
                    }
                    c8.pc += 2;
					break;

			}

			break;
	}
}
